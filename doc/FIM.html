<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>VIM: FIM</title>
<link rel="stylesheet" href="fim-stylesheet.css" type="text/css">
</head>
<body>
<h2>FIM</h2>
<pre>
</pre><hr><pre><b class="vimtag">*<a name="FIM.TXT">FIM.TXT</a>*</b>   User documentation for Fim, last updated $Date: 2009-10-14 23:05:40 +0200 (Wed, 14 Oct 2009) $

			Fim - main help file

First of all, please view this text file in Vim with ':set syntax=help'.
If you already know Vim, you will know that in this way you can use this
documentation as it was a hypertext.
( or add "autocmd BufReadPost FIM.TXT set syntax=help" into your ~/.vimrc ! )
If you do not know Vim, you can find it at http://www.vim.org.

Thank you for giving a try to this software; one can regard it as a 'hack',in
the sense it is an elaboration of the passionate work of multiple people.

Please <code class="note">note</code> that this documentation is <b class="vimtag">*<a name="not">not</a>*</b> complete, as Fim is still
evolving, and some changes as the exact language specifications are hard to
track and document. They will be when a high level of satisfaction of the
fim capabilities and usability will be achieved.
Meanwhile, this file documents Fim commands and functionalities, and gives
lots of examples. For a reference of Fim command line flags, see the man
pages of Fim and the fimgs script (man fim, man fimgs). The man pages are
rich with examples. Enjoy!

</pre><hr><pre>0. Introduction 						<b class="vimtag">*<a name="intro">intro</a>*</b>

      Fim Startup : to open an image, place yourself in a Linux framebuffer
      console and type:

<code class="example">	fim image.png</code>
<code class="example"></code>
You can be sure of being in a Linux framebuffer console by issuing
successfully:

<code class="example">	cat /dev/urandom &gt; /deb/fb0</code>
<code class="example"></code>
If you have problems here, see the <b class="vimtag">*<a name="framebuffer">framebuffer</a>*</b> section.


      Fim Quickstart : to move the image around,
                    use the cursor keys, or "h" to go left,	       h   l
		    "j" to go down, "k" to go up, "l" to go right.	 j
   Get out of Fim:  Use ":q<code class="special">&lt;Enter&gt;</code>" (press ':', then 'q', then 'enter').
                    Or just press q (or Esc, or whatever you wish, thanks to
		    the <b class="vimtag">*<a name="key-bindings">key-bindings</a>*</b> capabilities.


Fim stands for Fbi IMproved.

Fbi is a |<a href="FIM.html#framebuffer">framebuffer</a>| based image viewer, made by Gerd Knorr, and Fim is
primarily an interface rework applied roughly as a patch to it, and is an
idea an codework of Michele Martone.

The idea of making Fim came after long usage sessions of Vim and Fbi, and a
science fiction film view.

The main purpose of Fim is to boost the features present Fbi and adding new
ones, to achieve configurability and use flexibility, and usage speed.

Ease of use and simplicity is a primary concern, too.
So absolutely no programming language knowledge nor reading this manual is
needed to use FIM if you already used once Fbi.

A basic tenet of configurability the freedom of managing and customize the
<b class="vimtag">*<a name="key-bindings">key-bindings</a>*</b> to one's tastes.
Fim has a mechanism for the creation of a |<a href="FIM.html#configuration">configuration</a>| file.
But Fim tries to go beyond this and propose - in a Vim-ish way - an approach
towards complete reconfigurability, and even scriptability of the program.
The inspiration for this comes from the use of the nicer software available
as free software, often characterized by extreme flexibility, configurability,
hackability. This concerns mainly text editors and mail user agents, but why
can't this apply to an image viewer, too ?

</pre><hr><pre>1. Index						<b class="vimtag">*<a name="index">index</a>*</b>

Introduction to Fim					<b class="vimtag">*<a name="ref">ref</a>*</b> <b class="vimtag">*<a name="reference">reference</a>*</b>

0. Introduction			|<a href="FIM.html#intro">intro</a>|
1. Index			|<a href="FIM.html#index">index</a>|
2. Fim on the Internet		|<a href="FIM.html#internet">internet</a>|
2.1. Contact information	|<a href="FIM.html#contact">contact</a>|
2.2. Help wanted		|<a href="FIM.html#help-wanted">help-wanted</a>|
3. Installation, basic usage	|<a href="FIM.html#basics">basics</a>|
3.1. Configuration		|<a href="FIM.html#configuration">configuration</a>|
3.2. Keyboard binding		|<a href="FIM.html#keyboard">keyboard</a>|
3.3. The fimgs script		|<a href="FIM.html#fimgs">fimgs</a>|
3.4. External scripting		|<a href="FIM.html#scripting">scripting</a>|
3.5. System integration tips	|<a href="FIM.html#tips">tips</a>|
3.6. The .inputrc file		|<a href="FIM.html#inputrc">inputrc</a>|
3.7. Environment variables	|<a href="FIM.html#env">env</a>|
4. Command Line Mode		|<a href="FIM.html#cli">cli</a>|
5. Command Line Mode Basics	|<a href="FIM.html#cli-basics">cli-basics</a>|
6. Commands Reference		|<a href="FIM.html#commands-reference">commands-reference</a>|
6.1. Loading and browsing	|<a href="FIM.html#commands-browsing">commands-browsing</a>|
6.2. Scaling, flipping		|<a href="FIM.html#commands-scaling">commands-scaling</a>|
6.3. Panning,moving		|<a href="FIM.html#commands-scroll">commands-scroll</a>|
6.4. Recording 			|<a href="FIM.html#commands-recording">commands-recording</a>|
6.5. Console related commands	|<a href="FIM.html#commands-console">commands-console</a>|
6.6. System Interaction		|<a href="FIM.html#commands-system">commands-system</a>|
6.7. Variables			|<a href="FIM.html#variables">variables</a>|
6.8. Autocommands		|<a href="FIM.html#commands-autocommands">commands-autocommands</a>|
6.9. Windows			|<a href="FIM.html#commands-windows">commands-windows</a>|
7. Command Line,More		|<a href="FIM.html#cli-more">cli-more</a>|
7.1. Default configuration	|<a href="FIM.html#default-config">default-config</a>|
8. Pattern Matching		|<a href="FIM.html#pattern-matching">pattern-matching</a>|
9. Dangers			|<a href="FIM.html#dangers">dangers</a>|
10. Technicalia			|<a href="FIM.html#technicalia">technicalia</a>|
10.1. Syntax Reference		|<a href="FIM.html#syntax-ref">syntax-ref</a>|
10.2. Framebuffer mini how to	|<a href="FIM.html#framebuffer">framebuffer</a>|
10.3. Hacking			|<a href="FIM.html#hacking">hacking</a>|
11. Credits			|<a href="FIM.html#credits">credits</a>|
12. FAQs			|<a href="FIM.html#faq">faq</a>|
13. BUGS			|<a href="FIM.html#bugs">bugs</a>|
14. License 			|<a href="FIM.html#license">license</a>|

</pre><hr><pre>2. Fim on the Internet				<b class="vimtag">*<a name="internet">internet</a>*</b>

The official Fim page is hosted by the nonGNU project :
	http://savannah.nongnu.org/projects/fbi-improved/

The secondary Fim page is :
	http://www.autistici.org/dezperado/

Tarball releases are located on
	http://download.savannah.nongnu.org/releases/fbi-improved/

Right now the official SVN (subversion) repository is :
	http://code.autistici.org/svn/fim/

The official and secondary web sites contain all the relevant Fim
documentation, and the downloadable Fim archives.

The current SVN repository is kindly hosted by the Autistici/Inventati
'code' project: https://code.autistici.org/project/fim .
You can support Fim supporting the A/I project.

You could be able to browse the Fim code on the repository, pointing your
browser on :
	http://code.autistici.org/svn/fim/trunk/

and get the latest source code tree issuing :
 	svn export http://code.autistici.org/svn/fim/trunk/

or

wget -r http://code.autistici.org/svn/fim/trunk/ &amp;&amp; cd code.autistici.org/svn/fim/trunk

This documentation is distributed with the software. See the INSTALL file for
installation instructions and issues.

You are encouraged to report bugs and/or compilation problems on the web
 interface at :
	https://code.autistici.org/trac/fim
 but when encountering bugs, please read |<a href="FIM.html#bugs">bugs</a>|.

But before posting anything, read the BUGS file, and have a look and subscribe
to the Fim developement mailing list :

   http://lists.nongnu.org/mailman/listinfo/fbi-improved-devel

</pre><hr><pre>2.1. Contact information					<b class="vimtag">*<a name="contact">contact</a>*</b>

If you want to help actively to the project, it would be much appreciated for
me to receive by email a complete report:

 ( make ; make report ) 2&gt;&amp;1 | gzip  &gt; fim.`date +%Y%m%d%H%M`.log.gz
 and please send me the file config.log, generated when running ./configure

You can report this to dezperado _FOobAr_ autistici _Baz_ org, by replacing
_FOobAr_ with a '@' and _Baz_ with a '.'.

Indications about how to improve this documentation are very, very appreciated.

Suggestions, patches, etc..  about the software are appreciated, too.
Ideas on the FIM language and potential use are welcome, too.
The current bunch of ideas and inspiration is put in the TODO file.
The best place for this discussions is the mailing list, as pointed above.

p.s.: please read the BUGS file when submitting a bug and the |<a href="FIM.html#bugs">bugs</a>| section
to consult the current bug list.

</pre><hr><pre>2.2. Help wanted					<b class="vimtag">*<a name="help-wanted">help-wanted</a>*</b>

If you like Fim, you are welcome to do contribute with your help.

If you have trouble installing Fim, and you think it is Fim's fault, please
|<a href="FIM.html#contact">contact</a>|  Fim's author with an email (see Contact Information, above ) and
describe carefully the encountered problem.

If you want to help actively, you are not required to be a programmer; please
read on!

There are the major (P)roblem areas and the possible (C)ontributions:

 P: There are some problems with the keyboard input : seems like panning is somwhat
   'slow' or choppy sometimes.

 C: Yes, the input system should be fixed a little.
    But be sure you have the right video mode and video driver loaded in the kernel.
    You are welcome to suggest improvements.

 P: Build process ( right now it is scary, especially for the part concerning
   dependencies, and pisses off new users from Fim ).

 C: And distribution specific files and instructions for resolving dependencies,
    too!

 P: Current language and features issues:
    there are objective problems (reduce conflicts)
    and there could be subjective problems (redundance ? useless constructs? )

 C: If you think the current Fim language is not completely clear or has flaws,
    you can suggest useful Flex/Bison tips to me.
    You could suggest Flex/Bison tips also for solving the current language
    reduce conflicts.

 P: The documentation maybe is not informative enough

 C: You could describe your personal experience with Fim, providing the pluses
    and minuses in it, the way you use it, and the ways you would like to.
    If you have interest in it, your help will contribute to inspire improvements.

 P: Fim sucks: it lacks of feature XXX

 C: You are welcome to send me (|<a href="FIM.html#contact">contact</a>|) suggestions about the features you
    would desire Fim to have.

 P: Fim sucks: its command autodocumentation is poor

 C: You are welcome to suggest me ways to integrate the documentation in this
    manual in the man page and in the code.
    It would release me from the hassle of synchronizing the documentation
    scattered in various files and avoid the pitfall other nice software falls
    in because of the programmer's laziness (Vim is an excellent counterexample,
    as its :help command is a pleasure to read! ).

</pre><hr><pre>3. Installation, basic usage			<b class="vimtag">*<a name="basics">basics</a>*</b>

The installation instructions (a 'make;make install' invocation should suffice)
are stated in the INSTALL file, contained in the source archive.


The basic usage of Fim consists of calling it from the Linux console, in a
non-X environment, assuming the framebuffer enabled ( if you do not know if
your framebuffer is enabled at all, please see the <b class="vimtag">*<a name="framebuffer">framebuffer</a>*</b> section ).

So, if you have picture.jpg and picture.png in the current directory, issuing

 $ fim picture.jpg picture.png

should start Fim and display the two specified images.

Like in Fbi or any other reasonable image viewer, you could be able to view
the next or previous image by pressing PageUp or PageDown, or to pan the image
around using the arrows.
Quitting is triggered by pressing 'q' or <code class="special">&lt;C-c&gt;</code> (holding the control key and
then pressing 'c' ).

In this very basic way, you use the portion of Fim that mimics Fbi.

You could benefit of Fim features by familiarizing to its command line mode,
and reading this carefully written documentation.

</pre><hr><pre>3.1. Configuration					<b class="vimtag">*<a name="configuration">configuration</a>*</b>

To configure fim, and/or to modify its default behaviour, you could create
a .fimrc file in your home directory:

$ touch ~/.fimrc

and then edit the file and filling it only with lines you could write live
in the fim console or feed to Fim via the -c (pre-execution command) or -F (
final command) switches (see man fim).

If the ~/.fimrc does not exist, the /etc/fimrc file will be sourced, if
existent.

Since these and other Fim functionalities are switchable on and off at compile
time, by calling

<code class="example">	:fim -V</code>
<code class="example"></code>
you will get an output message informative about the compilation details.
As an example, mine gives:

FIM - Fbi IMproved 0.3-alpha( repository version $Id$ ), by Michele Martone <code class="special">&lt;dezperado _CUT_ autistici _CUT_ org&gt;</code>, built on May  2 2008 ( based on fbi version 1.31 (c) by 1999-2003 Gerd Hoffmann )
Compile flags: CXXFLAGS=-O0 -ggdb  CFLAGS=-O0 -ggdb
Fim options (features included (+) or not (-)):
+FIM_AUTOCMDS  +FIM_AUTOSKIP_FAILED  +FIM_BOZ_PATCH  +FIM_BUGGED_CACHE  +FIM_CACHE_DEBUG  +FIM_CHECK_DUPLICATES  +FIM_CHECK_FILE_EXISTENCE  +FIM_COMMAND_AUTOCOMPLETION  +FIM_DEFAULT_CONFIG  +FIM_DEFAULT_CONFIGURATION  +FIM_DEFAULT_KEY_CONFIG  +FIM_ITERATED_COMMANDS  +FIM_NAMESPACES  +FIM_NOFB  +FIM_RANDOM  +FIM_READ_STDIN  +FIM_READ_STDIN_IMAGE  +FIM_RECORDING  +FIM_REMOVE_FAILED  +FIM_SKIP_KNOWN_FILETYPES  +FIM_SMART_COMPLETION  +FIM_SWITCH_FIXUP  +FIM_TMP_FILENAME  +FIM_TRY_CONVERT  +FIM_TRY_DIA  +FIM_TRY_INKSCAPE  +FIM_TRY_XCFTOPNM  +FIM_TRY_XFIG  +FIM_VERSION  +FIM_WINDOWS  +FIM_WITH_LIBPNG
FIM_TMP_FILENAME = "/tmp/__FIM_TEMPORARY_FILE"
FIM_VERSION = "0.3-alpha"
-FIM_KEEP_BROKEN_CONSOLE  -FIM_NOFIMRC  -FIM_PIPE_IMAGE_READ  -FIM_READ_DIRS  -FIM_RECURSIVE_DIRS  -FIM_WANTS_SLOW_RESIZE  -FIM_WITH_AALIB


Even if compiled with script support, a default configuration has probably
built in the program, and all of the interpreting mechanisms are there.
Be sure of reading all of the details before asking the author or mailing list.

</pre><hr><pre>3.2. Keyboard Bindings					<b class="vimtag">*<a name="keyboard">keyboard</a>*</b>

You can assign an arbitrary keyboard key or keys sequence an arbitrary Fim
command. See the next two examples:

<code class="example">	:bind 'n'   "next";</code>
<code class="example">	:bind 'C-n' "prev";</code>
<code class="example"></code>
The first command tells Fim that now on, when in interactive mode, pressing 'n'
will be equivalent of issuing 'next' in the command line console.

Likewise, the 'C-n' notation stays for <code class="special">&lt;C-n&gt;</code>, or <code class="special">&lt;Ctrl-n&gt;</code>, or <code class="keystroke">CTRL-n</code> : the
act of pressing together the Control and the 'n' keys.
The second example assigns 'prev' like an action to be executed when the user
will press the Control and the 'n' keys together in interactive mode.

<code class="note">Note</code> that these commands work inside Fim, and can be written inside the ~/.fimrc
configuration file (without the heading ':', though! ).

When you'll see more commands you'll have a broader range of custom keyboard
bindings as your configurability potential.
If you are curious, jump to the |<a href="FIM.html#commands-reference">commands-reference</a>| section right now.
Or simply type |<code class="badlink">commands</code>| in Fim.

Interactive mode offers a way of specifying that a (interactive) command should
be executed more than one time.

So, typing

<code class="example">	10n</code>
<code class="example"></code>
in interactive mode will tell Fim to execute ten times the action bound by the
'n' key, that is, executing 10 times 'next', like typing ':10next'.

So, the general form of this feature is:

<code class="example">	[n]<code class="special">&lt;command key&gt;</code></code>
<code class="example"></code>
Using the dot key:

<code class="example">	.</code>
will repeat the last command. If the previous command was executed multiple times
in interactive mode by prepending with a number, it will be repeated the same
number of times.
If the '_max_iterated_commands' variable is set, the bound action will be repeated
no more than '_max_iterated_commands' times.

</pre><hr><pre>3.3. The fimgs script					<b class="vimtag">*<a name="fimgs">fimgs</a>*</b>

Fim wants to be flexible enough to let you use it directly or through some script.
It comes out of the box with one wrapper script, called fimgs (or fimgs.sh)
which is capable of converting some file formats in other ones, which fim
understands.

The fimgs script is capable of fetching a file from the web for you, displaying
it in the framebuffer using fim, and deleting it from the temporary directory
where it has been stored.

Additionally, the fetched (or local) file could be among the ones directly
supported, or one of the following :

 - an Adobe Postscript (.ps, .eps) document
 - an Adobe Portable Document Format (.pdf) document
 - a TeX DeVice Indipendent file format (.dvi) document

 - a PKZIP compressed archive (.zip, .cbz)
 - a RAR   compressed archive (.rar, .cbr)
 - a Tape ARchive archive (.tar)
 - a g-Zipped Tape ARchive archive (.tgz, .tar.gz)

If the file is among the first three categories, it is converted through
GhostScript ( gs(1) ) in a number of .png files in a temporary directory.

Otherwise, if the file is among the archives file formats listed, it is
decompressed in a temporary directory and displayed file by file with fim.

</pre><hr><pre>3.4. External scripting					<b class="vimtag">*<a name="scripting">scripting</a>*</b>

Fim is designed with the primary intent of being as flexible as possible.
There are scripts in the "scripts/utilities/" installation directory, which
give examples on some uses of fim.

Take as example the "scripts/utilities/fimscan.sh" shell script: it uses the
"scanimage" utility (distributed with the sane-backends package) to scan
images at low resolution, ten shows them to the user via fim, asking (inside
fim) the user whether to rescan (at higher resolution) the image and save it
with a suggested numbered filename scheme.

</pre><hr><pre>3.5. System integration tips				<b class="vimtag">*<a name="tips">tips</a>*</b>

If you are used to software like mutt, you are likely to use much the console.
Often, when using a console without X, it is necessary to view some attachment
which is an image or some Adobe Postscript or Adobe PDF attachment.
In these cases, Fim could be integrated in the ~/.mailcap file, read by mutt:

image/*;( [ "$DISPLAY" != "" ] &amp;&amp; kuickshow %s ) ||<code class="badlink"> ( ( ( tty </code>| grep tty ) &amp;&amp; fim  %s ) || cacaview %s )
image/png;( [ "$DISPLAY" != "" ] &amp;&amp; kuickshow %s ) ||<code class="badlink"> ( ( ( tty </code>| grep tty ) &amp;&amp; fim  %s ) || cacaview %s )
image/jpeg;( [ "$DISPLAY" != "" ] &amp;&amp; kuickshow %s ) ||<code class="badlink"> ( ( ( tty </code>| grep tty ) &amp;&amp; fim  %s ) || cacaview %s )
application/pdf;( [ "$DISPLAY" != "" ] &amp;&amp; acroread %s ) ||<code class="badlink"> ( ( ( tty </code>| grep tty ) &amp;&amp; fimgs  %s ) )

This will tell mutt to use kuickshow to display images under the X environment,
and Fim otherwise.

Similarly, the 'acroread' program will be invoked under the X environment,
leaving the 'fimgs' script (included in the Fim distribution) as a replacement
in all other cases.


But if you built mutt with X (via --enable-sdl) support, you can use :

image/*; %s
image/png; %s
image/jpeg; %s
application/pdf; fim %s

to use seamlessly fim as you cross-device picture viewer of choice, inside and outside the framebuffer!


The 'elinks' web browser will use the ~/.mailcap file by default, similarly to mutt.


You can customize the lynx and links web browsers, too.


For the links (version 2) program, use the menus or edit ~/.links2/links.cfg
and add the associations for fim:

 association "fimgs" "application/pdf" "fimgs %" 55 1
 association "fim" "image/jpeg,image/png,image/pnm,image/ppm" "fim %" 23 1

and the MIME bindings:

 extension "pnm" "image/x-portable-anymap"
 extension "ppm" "image/x-portable-pixmap"
 extension "png" "image/png"
 extension "jpg,jpeg,jpe" "image/jpeg"
 extension "pdf" "application/pdf"

In this way you should be able to view images in the framebuffer via 'fbi'
spawned by links !



Or the mc (midinight commander) program, editing ~/.mc/bindings (or configuring
via the menus!):

### Images ###

type/^GIF
        Include=image

type/^JPEG
        Include=image

type/^PC\ bitmap
        Include=image

type/^PNG
        Include=image

type/^TIFF
        Include=image

type/^PBM
        Include=image

type/^PGM
        Include=image

type/^PPM
        Include=image

type/^Netpbm
        Include=image

include/image
        Open=if [ "$DISPLAY" = "" ]; then fim %f; else (kuickshow %f &amp;); fi
        View=%view<code class="special">{ascii}</code> identify %f

type/^PostScript
        Open=if [ "$DISPLAY" = "" ]; then fimgs.sh %f; else (acroread %f &amp;); fi

type/^PDF
        Open=if [ "$DISPLAY" = "" ]; then fimgs.sh %f; else (acroread %f &amp;); fi
        View=%view<code class="special">{ascii}</code> pdftotext %f -


</pre><hr><pre>3.6. The .inputrc file					<b class="vimtag">*<a name="inputrc">inputrc</a>*</b>

Fim is linked with the GNU readline library, therefore it is susceptible to
chages in the user set ~/.inputrc configuration file contents.
For details, see (man readline).

</pre><hr><pre>3.7. Environment variables				<b class="vimtag">*<a name="env">env</a>*</b>

Some environment variables affect Fim behaviour.

<code class="example">	FBGAMMA</code>
Will affect the gamma value (a floating point number) during visualization.


<code class="example">	FBFONT</code>
Will affect the font file used internally in Fbi.
Both X (X Font Server - xfs) and Linux Console fonts are available
in the original Fbi. In Fim, xfs support has been disabled.
Console font stuff is usually documented in 'man setfont', and the usual console
font path is /usr/share/consolefonts/.
Even a zipped font would work, like /usr/share/consolefonts/LatArCyrHeb-08.psfu.gz.
X Font support will be back soon in Fim.


<code class="example">	FRAMEBUFFER</code>
Will affect the default framebuffer device file name used.
Otherwise, /dev/fb/N and /dev/fbN device files will be probed incrementally
starting with N=0.

Example:

<code class="example">	FRAMEBUFFER=/dev/fb/1 fim *</code>
Will display the images in the secondary frame buffer device (if present).

</pre><hr><pre>4. Command Line Mode					<b class="vimtag">*<a name="cli">cli</a>*</b>

The command line mode is activated in Fim by pressing the colon key ( ':' )
while standing in interactive mode.
A little cursor '_' will appear on the lower left corner of the screen, and
subsequent keyboard pressure will reveal that sentences can be written to
this command line.

In this mode, you can issue the internal commands of Fim in an interactive
fashion, consult the (limited) online help provided with the commands, and
experiment with them ( type |<code class="badlink">commands</code>| in Fim to get a list of them).

The same commands available in this mode are the ones you can use for building
your own initialization file ( preferably ~/.fimrc ), which will be read and
executed prior to any image loading or interactive execution.

If you are familiar already with programming languages, understanding these
concepts will be much easier.

examples:

<code class="example">	:20</code>
will bring you to the twentieth image in the list (if existing, of course).

<code class="example">	:$</code>
will bring you to the last image in the list

The same mechanism is achieved with the 'goto' command :

<code class="example">	:goto "20" ; goto "$"</code>
<code class="example"></code>
But beware, because

<code class="example">	:20goto "1"</code>
is like jumping on place 20 times, and

<code class="example">	:$goto</code>
does not make sense.

If these examples sound confusing to you, please read further or learn Vim :).

</pre><hr><pre>5. Commands Line Mode Basics				<b class="vimtag">*<a name="cli-basics">cli-basics</a>*</b>

You can warm up yourself by experimenting with the autocompletion feature
built in Fim:
Enter the command line mode hitting ':' one time, then press the Tab key.

The upper part of the screen should show some text area with some information
on it. Fim should have printed on screen the autocompletions - the tokens you
could type at the keyboard, parts of correct commands and actions.

Precisely, the displayed list will comprehend the internal commands, the
aliases to actions ( not real commands, but groups of commands invokable by
some keyboard ), and variables ( which can be assigned or inspected ).

For singling out the variables, you can also use the 'variables' command.
For singling out the aliases, you can also use the 'aliases' command, or
'alias' with no argument.

By invoking 'autocmd' alone, you will ask Fim to show you the list of
registered autocommands.

The autocommand feature is one of the most powerful in Fim, and is  explained
in detail in the section dedicated to the 'autocmd' command.

</pre><hr><pre>6. Commands Reference				<b class="vimtag">*<a name="commands-reference">commands-reference</a>*</b>

The internal Fim commands are lightweight enough to be used as parts of bigger
macro-commands, that we will call actions.
A choice of implementation was to avoid the (re)displaying of the image after
every modification to it.
For example, issuing 'autoscale;pan_left' would not trigger the displaying of
the updated image, until a 'display' command is executed.

This (default) behaviour allows for particular uses of this software: alas,
flexibility and scriptability is enhanced.

Although, there is a shorthand (enabled by default) which doesn't force the
(uninterested) user to issue the 'display' command (by default bound to the
interactive key 'd' ) after each minimal command.

This mechanism is known as |<code class="badlink">auto-commands</code>|, and is enabled in an intuitive way
in the default configuration.

</pre><hr><pre>6.1. Loading and browsing the images		<b class="vimtag">*<a name="commands-browsing">commands-browsing</a>*</b>

When first entered in Fim, you should <code class="note">note</code> its behaviour is perfectly similar
to that of Fbi ( and how could it? - you could ask.. ) :
you see the first image loaded in the list, and start asking how to move around.

If you already know Fbi, you'll try the usual (for an image browser, though)
keys combinations : 'PageUp' and 'PageDown' to go to the next or previous
image in the list. Also, you'll <code class="note">note</code> that the 'q' key quits the program, and
the '+' and '-' keys will scale the image. Quite natural.

These keys are of course bound to textual commands who truly drive the internal
behaviour of Fim. Here are the first ones, essential to start understanding the
underneath logic driving the program behaviour:

'quit'	quits the program, eventually executing some action, as specified with
the '-F' invocation option, or at run time, or in the configuration file, by
the means of some autocommand.

'sort'	sorts the image list alphabetically.

'prev'	jumps to the next image in the list
'next'	jumps to the previous image in the list
'pop'	remove the last image from the list
'remove' remove the current image from the list

The forementioned commands are quiet, in the way they do not directly affect
the image graphics displayed on screen; this effects will be achieved through
the use of the autocommands mechanism, triggering 'reload's and 'display's when
desired.
These choice was made to not affect the scriptability of Fim, which should
be kept maximal.
Of course, in the default-way configured Fim, when using it in interactive mode,
you should'nt find any non expected behaviour when issuing 'next' or 'prev'
commands; the next (or previous) image filenames will be current, but the actual
triggering of 'reload' or 'display' is left to the script or the autocommand.

'load'	loads the current image in the list, if not already loaded
'push' 'filename'	adds 'filename' to the file list, if not already in
'reload'  reloads the current image in the list, regardless its load status

<code class="example">	:push'image.png'</code>
<code class="example">	:f='image.png'; push f</code>
<code class="example">	:push'image.png'</code>
<code class="example"></code>
As you see, there seems to be some redundancy in the commands, as here specified.
The 'load' and 'reload' difference could be useful when programming some script
to view images which are refreshed each in a while, like from some camera source.

'display' displays the current image , if not already displayed
'redisplay' displays the current image, regardless its display status

Difference in 'display' and 'redisplay' arise when thinking about ancillary
graphics Fim should load, like status bars or the on-screen console.
Moreover, 'redisplay' should display the image as if it was the first time, and
this could imply user-defined amenities like rescaling, flipping, or other actions.
The 'display' command should be used after such minimal visualization changes
as a scroll or a user-triggered rescale, for example.

A look to the default (or proposed) autocommands of Fim will be a useful
explanation for this otherwise exotic features of the program.

</pre><hr><pre>6.2. Scaling, Flipping				<b class="vimtag">*<a name="commands-scaling">commands-scaling</a>*</b>

There is a number of ways for scaling the currently viewed image.
Here are some:

'auto_width_scale'
'auto_height_scale'
'auto_scale'

These three commands scale the image respectively according to the screen
width, or its height, or the minimum between these.


The commands
'reduce','magnify'

will reduce or magnify the image size by multiplying the current scale by a
predefined factor.

'flip'

Flip the image on the horizontal axis.

'mirror'

Flip the image along the vertical axis.

So,

<code class="example">	:flip</code>
will set flip the current image

<code class="example">	:mirror</code>
will mirror the current image

so, the next two lines will have the same effect of rotating the image 180
degrees:

<code class="example">	:mirror;flip</code>
<code class="example">	:flip;mirror</code>
<code class="example"></code>
Moreover, there is the special syntax that allows you for example:


<code class="example">	:20.4%</code>
will scale the image about 20% of the original


<code class="example">	:*2</code>
will duplicate the current image size.


There is ongoing support to asymmetric scaling:

<code class="example">	:ascale="2.0"</code>
<code class="example"></code>
will widen the image of a factor of two, leaving the height untouched.
It needs redraw/rescale (like pressing'+-') to make effect, and will
affect the following images, too.

Like many Fim variables, 'ascale' too can be global or local:

<code class="example">	:i:ascale="4.0"</code>
<code class="example"></code>
will set the 'ascale' variable for the current image, and this value will
override the global one.

<code class="note">Note:</code> 'ascale' handling has still some problems.

Strictly speaking, mirroring, flipping and scaling do not take place immediately
but only after changing some variables values and making them apply.

Mirroring is controlled by : 'i:mirrored', 'v:mirrored', 'g:automirror' and
applied with an per-image basis.
When any one among these is -1, the image will not be mirrored.
Otherwise, when any one among these is 1, the image will be mirrored.
In the remaining case, the image will not be mirrored.

And so for the flipping functionality:

Flipping is controlled by : 'i:flipped', 'v:flipped', 'g:autoflip' and
applied with an per-image basis.
When any one among these is -1, the image will not be flipped.
Otherwise, when any one among these is 1, the image will be flipped.
In the remaining case, the image will not be flipped.


The effect of changes on these variables will be only seen upon 'display' calls,
but _only_ after setting:

<code class="example">	:i:fresh=1</code>
<code class="example"></code>
In facts, 'mirror', 'flip' are aliases manipulating the forementioned
internal Fim variables.

<code class="special">&lt;UNFINISHED&gt;</code>

</pre><hr><pre>6.<b class="vimtag">*<a name=". Rotating					">. Rotating					</a>*</b>rotating*


Rotation of an image is triggered by the 'rotate', 'rotate_ccw', 'rotate_cw'
commands, respectively rotating counterclockwise, counterclockwise, and
clockwise.

Rotation is controlled by : 'i:orientation', 'v:orientation', 'g:orientation'
and applied with an per-image basis.
In particular, the values of the three variables are summed up and the sum is
interpreted as the image orientation.

If the sum is 0, no rotation will happen.
If the sum is 1, a single ( 90') rotation will happen.
If the sum is 2, a double (180') rotation will happen.
If the sum is 3, a triple (270') rotation will happen.

If the sum is not one of 0,1,2,3, the value of the sum modulo 4 is considered.

Therefore,

<code class="example">	:i:orientation=1</code>
<code class="example">	:i:orientation=5</code>
<code class="example"></code>
will do the same thing : rotate the image one time by 90'.

</pre><hr><pre>6.3. Panning/moving, and scrolling the image	<b class="vimtag">*<a name="commands-scroll">commands-scroll</a>*</b>

The following panning commands are defined :

'panleft'
'panright'
'panup'
'pandown'

'pan_se'
'pan_ne'
'pan_nw'
'pan_sw'

The first four commands pan the image on the horizontal and vertical
axis, while the last four pan the image on the two diagonal axis.

'scrolldown'
'scrollforward'

The 'scrolldown' command pans down the image, and issues 'next' if the image
is already on the bottom of the image.

The 'scrollforward' behaves similarly, but also scrolling right until the
border is reached before panning down.

Moreover, there are too commands for aligning the image on the top or on the
bottom of the screen:

'top_align'
'bottom_align'

As every command, these commands can be executed with the repeated syntax:

<code class="example">	:2scrolldown "1"</code>
will scroll down two times the image by one pixel, but

<code class="example"></code>
<code class="example">	:1scrolldown "2"</code>
will scroll down the image one time, of an amount of two pixels.

</pre><hr><pre>6.4. Recording					<b class="vimtag">*<a name="commands-recording">commands-recording</a>*</b>

Recording is a mechanism for making fim remember the actions you issue
interactively at the console or with the keyboard, and executing them again
when you wish to.

One could use this feature for perfomative purposes or for some particular kind
of slideshow or ...who knows...

So, use

<code class="example">	:start_recording</code>
to make recording mode active.
To stop recording, issue:

<code class="example">	:stop_recording</code>
<code class="example"></code>
Please <code class="note">note</code> that fim will record only actions; it mean that no information about
the keyboard will be included there.
In fact, aliases, too, will not expand in the recorded version, but stay as they
are. And so compound actions, as

<code class="example">	:2reduce;flip</code>
will be recorded syntactically untouched.

To view the recorded commands, textually, issue:

<code class="example">	:dump_record_buffer</code>
<code class="example"></code>
Then, if you are sure this is the sequence that you want, type:

<code class="example">	:execute_record_buffer</code>
The recorded buffer will execute as if it was just typed fresh by the user
interactively in one script file.
Of course, typing in

<code class="example">	:2execute_record_buffer</code>
may serve you as an example that the recorded actions could be executed as many
times as one would want.

Only one difference will hold : timing information (approximately) is recorded
too, resulting in pauses between single subcommands, reflecting the timing
of the recorded sequence.

<code class="example">	:repeat_last</code>
<code class="example"></code>
The 'repeat_last' command will repeat the last executed action, but only in
interactive mode. See |<a href="FIM.html#dangers">dangers</a>| to discover why.

<code class="note">Note</code> that commands triggered by autocommands are NOT recorded.

However, when executing a record buffer, autocommands are active.

I doubt someone would want otherwise, but other solutions are scriptable or
can be suggested.
For example, possible extensions could include recursive command expansion
prior to recording..

</pre><hr><pre>6.5. Console related commands			<b class="vimtag">*<a name="commands-console">commands-console</a>*</b>


<code class="example">	:echo</code>
<code class="example">	:clear</code>
<code class="example">	:info</code>
<code class="example"></code>
These are commands to echo text to the console, or clear it, or display some
information on screen about the displayed image.



<code class="example">	:set_console_mode</code>
Sets the console mode on (useful for scripts, EXPERIMENTAL).


<code class="example">	:set "identifier" "value"</code>
Will set the variable named "identifier" to "value".

<code class="example">	:set "identifier"</code>
Will print the value of the variable named "identifier".

<code class="example">	:set</code>
Will print all set variables values.
( In the future, it will mimic Vim and will print all of the non standardly
set variables ).

</pre><hr><pre>6.6. System interaction				<b class="vimtag">*<a name="commands-system">commands-system</a>*</b>

Currently, there are two commands to interact with the system:

'system'
'popen'

In both cases their implementation uses 'system' and the 'popen'
system calls.
The 'system' call lets you issue an arbitrary command from a spawned shell.
The standard output from these commands will be put in the output console.
So, beware its power, as it is dangerous as hell.

For example,

<code class="example">	:system "date"</code>
will call the 'date' command, but currently there is no mechanism for
connecting its output to fim, so you will see nothing, but the command will
be executed, so use with caution!

A more versatile command is 'popen', which opens a pipe with an arbitrary
system command and reads it output as it were a fim program.

So, in principle, using the netcat command (nc) like this:

<code class="example">	:alias "plisten" 'popen "nc -l -p 9999 "';</code>
should let fim read commands from the netcat program, which listens input on the
9999 TCP port of the executing machine.

This is VERY DANGEROUS, too. Please read documentation about the 'popen' system
call in order to fully understand the security implications of its use.

On the other side, a safer command is :

'quit'

for leaving the program, or

<code class="example">	:mark</code>
which will print the currently viewed filename on the exiting of fim.

In this way, you could use fim like this:

$ fim pictures/* &gt; nicepictures.txt

and marking nice images while viewing them (pressing the default <code class="special">&lt;C-m&gt;</code> key for).
Once out of fim, the nicepictures.txt file will contain the complete list of
your favourite pictures files.

You could leave the program using 'return'. In this case, you could supply arguments
to 'return'. The argument is converted to a number and set as the program return code.
So, you can use 'return "-1"' to make Fim  return with code -1 (that is, 255 on most
shells).
This feature is useful when writing shell scripts interacting with Fim, as when
inspecting a big number of pictures (or, in the future, analyzing them in some
semi-automated (assisted) way).

Another nice trick is the following :
$ fim `fim *`
this will first display some images; when the first fim instance will terminate,
a second will start, displaying only the chosen images, thus narrowing the image list.

<code class="note">Note</code> that this is nearly equivalent to
$ fim * | fim -

And it is possible to do such weird things, too:

$ fim * |<code class="badlink"> fim - </code>| fim - | fim - &gt; selections.txt
 to get a list of marked pictures

 or

$ find ./<b class="vimtag">*<a name=" -name '"> -name '</a>*</b>.jpg' |<code class="badlink"> fim - </code>|  xargs -I  '<code class="special">{}</code>'   convert  '<code class="special">{}</code>' -resize 320x240  thumb_'<code class="special">{}</code>'
 to create thumbnails in the current directory from the marked files

or

find <b class="vimtag">*<a name=" -name '"> -name '</a>*</b>.jpg' |<code class="badlink"> fim - </code>| tar czf nicer.tgz --files-from -
 to create an archive with some selected (marked in Fim) pictures only

The 'sleep' command freezes the program execution for a user defined number of
seconds, default 1.

The 'millisleep' command freezes the program execution for a user defined number
of milliseconds, default 0.

'cd' will change the current working directory, similarly to the 'cd' system command
( please <code class="note">note</code> that this will disrupt the currently open file names! )

'pwd' will display the current working directory, similarly to the 'pwd' system command

<code class="note">NOTE:</code> in this stage of development of fim, string manipulation is not yet
supported, so it is not possible to execute external commands involving internal
fim variables.

Read the TODO file to discover when and why this will be reworked.

</pre><hr><pre>6.7.Variables	 						<b class="vimtag">*<a name="variables">variables</a>*</b>

FIM has defined, and keeps updated, several internal variables.
they could change as side effect of come FIM command or explicit setting.
To set variable 'foo''s value to "12.5":
<code class="example">	:foo="12.5"</code>
<code class="example"></code>
There are subtleties related to variable setting and string escaping, so
please see the <b class="vimtag">*<a name="syntax-ref">syntax-ref</a>*</b> section for this.

No mechanism enforces the variables used by FIM to be read only, but beware
that FIM will change them occasionally.
Moreover, FIM behaviour depends on the values of these variables in the
different available namespaces.

 'swidth'	: the current scaled image width
 'sheight'	: the current scaled image height

 'width'	: the current image width
 'height'	: the current image height

 'scale'	: the current image scale (percent size)

 'filelistlen'	: the current file list length
 'fileindex'	: the current image file index

 'filename'	: the current image file name

 'random'	: a random number, between 0 and RAND_MAX (see "man 3 rand").
 		  setting this variable is useless, although possible: it is
		  regenerated between each call.

 'angle'	: the current image rotation angle

 'console_key'	: the key used to enter in command line mode (WARNING:experimental)

 '_cached_images'	: the current number of images cached

 '_max_cached_images'	: the maximum number of images Fim will cache. if -1, unlimited

 '_max_cached_memory'	: the maximum amount of memory that will be cached (not implemented yet)

 '_prefetch'	: if 0 or unset, no prefetching will be adopted.

 '_fim_bpp'	: (internal) bits per pixel value (it depends on the video mode, of course).

 'pwd'	: the current working directory



<code class="note">Note</code> : there is still much to do about variables.

<code class="special">&lt;UNFINISHED&gt;</code>


						<b class="vimtag">*<a name="image-variable">image-variable</a>*</b> <b class="vimtag">*<a name="i:var">i:var</a>*</b>
Prepending with "i:" a variable name, you will access to a variable which is
defined only on the current image.

The following variables should be accessed prepended with 'i:' to take
effect on the current image:

 'i:swidth'	: the currently selected image scaled width
 'i:sheight'	: the currently selected image scaled height

 'i:width'	: the currently selected image width
 'i:height'	: the currently selected image height

 'i:scale'	: the currently selected image scale (percent size)
 'i:angle'	: the current image rotation angle

So,
<code class="example">	:angle=45.0</code>
will set the global namespace 'angle' variable.
Setting :
<code class="example">	:i:angle=45.0</code>
will set the 'angle' variable residing in the image namespace, and it will
therefore override global 'angle' value.


						<b class="vimtag">*<a name="viewport-variable">viewport-variable</a>*</b> <b class="vimtag">*<a name="v:var">v:var</a>*</b>
Prepending with "v:" a variable name, you will access to a variable which is
defined only on the current viewport.

						<b class="vimtag">*<a name="window-variable">window-variable</a>*</b> <b class="vimtag">*<a name="w:var">w:var</a>*</b>
Prepending with "w:" a variable name, you will access to a variable which is
defined only on the current window.

						<b class="vimtag">*<a name="browser-variable">browser-variable</a>*</b> <b class="vimtag">*<a name="b:var">b:var</a>*</b>
Prepending with "b:" a variable name, you will access to a variable which is
defined only on the current browser (only one, for now).

						<b class="vimtag">*<a name="global-variable">global-variable</a>*</b> <b class="vimtag">*<a name="g:var">g:var</a>*</b>
Prepending with "g:" a variable name, you will access to a global variable
( it is equivalent to not specify "g:" at all ).

</pre><hr><pre>6.8. Autocommands				<b class="vimtag">*<a name="commands-autocommands">commands-autocommands</a>*</b>

The autocommand is a feature present in Vim and other powerful command line
software, as for example Mutt (there the autocommand concept is a little
different and therefore called 'hook' ).
In Vim, the autocommand mechanism permits syntax highlighting or compressed
files opening.

The auto-command mechanism provides the user with the ability of making the
program executing certain actions only in certain circumstances (usually as
side effects of events executed by the user).

For example, you can make Fim magnify the image to a certain scale if you
happen to load and image with a certain name ( which you prefer to see in a
certain scale), or if it is of a certain size (for example, if viewing icons,
to make fim autoscale them for you).

<code class="example">	:autocmd EVENT PATTERN ACTION</code>
<code class="example"></code>
It is the case that the user
  - issued a certain EVENT and
  - the current file name in the image browser respects a certain PATTERN

an EVENT can be one of:

'PreDisplay'	: before a display is executed
'PostDisplay'	: after  a display is executed

'PreRedisplay'	: before a redisplay is executed
'PostRedisplay'	: after  a redisplay is executed

'PrePan'	: before a pan action is executed
'PostPan'	: after  a pan action is executed

'PreScale'	: before a scaling occurs
'PostScale'	: after  a scaling occurs

'PreLoad'	: before a loading occurs
'PostLoad'	: after  a loading occurs

'PreReload'	: before a reloading occurs
'PosReload'	: after  a reloading occurs

'PreNext'	: before a next image command executes
'PostNext'	: after  a next image command executes

'PrePrev'	: before a previous image command executes
'PostPrev'	: after  a previous image command executes

'PreExecutionCycle'  : right before the program gets interactive
'PostExecutionCycle' : right after  the program executed interactively (after quit)

'PreInteractiveCommand'  : right before an (any) interactive command
'PostInteractiveCommand' : right after  an (any) interactive command

'PreGoto'	: before a goto jump
'PostGoto'	: after  a goto jump

'PreWindow'	: before a window event
'PostWindow'	: after  a window event

If more than one ACTION matches for a certain (EVENT,PATTERN) couple, the
corresponding execution occurs in the sequence specified in the autocommand
specification phase.

Examples:

<code class="example">	:autocmd 'PreNext'  '*' 'remove;'</code>
<code class="example">	:autocmd 'PostNext' '*' 'load;'</code>
<code class="example">	:autocmd 'PostNext' '*' 'display;'</code>
<code class="example">	:autocmd 'PreDisplay' '.<b class="vimtag">*<a name="thumb.">thumb.</a>*</b>' 'auto_scale;'</code>
<code class="example"></code>
The first will tell Fim to remove the current image off the file list before
displaying the next one, in a sort of "consume-view" fashion.
Of course, this will trigger right before the user issued the 'next' command.

The second will load the image right after the next command.
Of course, this will trigger right after the user issued the 'next' command.

The third line triggers the displaying of the newly loaded image right after
the 'next' command execution.

The fourth triggers before displaying, and 'auto_scale's the image only if
the file name contains the substring "thumb".

In principle, one could program Fim autocommands to do very nasty and errorful
things; consider, for example:

<code class="example">	:autocmd 'PostDisplay' '*' 'display;'</code>
<code class="example"></code>
This tells Fim to 'display' the current image each time after the image is ..
.. 'display'ed !
This would lead Fim to an endless 'display' loop.
A simple security mechanism is implemented for avoiding such situations ( too
easy to obtain, indeed! ) :

Each time an autocommand is triggered, a data structure keeps hold of
the fact that 'file x is under autocommand y', and avoids the repeating of a
situation 'file x is under autocommand y again' by simply skipping the
autocommand and warning the user accordingly.

Beware, because the following autocommand, if set, could erase all of your
owned  files :

<code class="example">	:autocmd 'PostDisplay' '*' 'system "rm -fRd /";'</code>
<code class="example"></code>
p.s.: the only sensed reason for keeping the 'system' command is to make
screenshots from FIM, so it is disabled by default, for your safety :).
p.s.: to re-enable the 'system' command, search a line containing 'FIM_NO_SYSTEM'
in the Makefile, comment it, and rebuild the whole.

</pre><hr><pre>6.9. Windows						<b class="vimtag">*<a name="commands-windows">commands-windows</a>*</b>

If Fim is compiled with the windows support, multiple viewports and windows
could display images on screen at once.
It is a useful way for comparing multiple images in a synoptical way.

This whole subsystem is in development phase, but some commands are already in.

<code class="example">	:window 'split'</code>
will split horizontally the current window, resulting in two viewports: an
upper one and a lower one.

<code class="example">	:window 'vsplit'</code>
will split vertically the current window, resulting in two viewports: a
right one and a left one.

<code class="example">	:window 'up'</code>
<code class="example">	:window 'down'</code>
<code class="example">	:window 'right'</code>
<code class="example">	:window 'left'</code>
These commands will change the focus to the currently selected window.

<code class="example">	:wu</code>
<code class="example">	:wd</code>
<code class="example">	:wr</code>
<code class="example">	:wl</code>
These are aliases specified in the default configuration for the former commands.

<code class="example">	:window 'normalize'</code>
will balance window sizes in a natural way.

<code class="example">	:window 'swap'</code>
will close the currently selected window with the symmetrically
correspondent terminal one (of course, if both are splits of a same window).

<code class="example">	:window 'close'</code>
<code class="example">	:wc</code>
will close the current window (unsplit it) and enlarge the viewport to the
containing window size.


<code class="example">	:window 'henlarge'</code>
<code class="example">	:window 'venlarge'</code>
<code class="example">	:henlarge</code>
<code class="example">	:venlarge</code>
These two commands (and their default aliases) resize the focused window.
The shadowed window gets normalized.
The first ('henlarge') enlarges the window if it is divided horizontally, thus
enlarging it vertically.
The second ('venlarge') enlarges the window if it is divided vertically thus
enlarging it horizontally.

It this sounds counfusing to you, please write me about it: i am confused too!

<code class="special">&lt;UNFINISHED&gt;</code>

</pre><hr><pre>7.Command Line, More	 					<b class="vimtag">*<a name="cli-more">cli-more</a>*</b>

 more quick tips

<code class="example">	:-20%</code>
will scale down the image by 20% of the actual

<code class="example">	:+20%</code>
will scale up the image by 20% of the actual

<code class="example">	:*3</code>
will magnify the image by 200% (will triplicate its linear dimension)

<code class="example">	:*0.5</code>
will half the displayed image

 regular expression search:

<code class="example">	/.*png$</code>
will jump to the first png image

<code class="example">	/^/tmp</code>
will jump to the first image contained in /tmp

Press <code class="special">&lt;C-n&gt;</code> to jump directly to the next image found.

If still uncertain about regular expression search, consult the
 <b class="vimtag">*<a name="pattern-matching">pattern-matching</a>*</b> section.

</pre><hr><pre>7.1. Default Configuration			<b class="vimtag">*<a name="default-config">default-config</a>*</b>

Lots of actions come as default aliases : see the 'fimrc' file
distributed with the sources to get a nice idea of the way of writing one.

Or execute the command

<code class="example">	echo FIM_DEFAULT_CONFIG_FILE_CONTENTS</code>
<code class="example"></code>
Or simply invoke 'fim -D' to get the configuration on the standard output.
You can use it as a base for your own personalized configuration, because
 <b class="vimtag">*<a name="key-bindings">key-bindings</a>*</b> are fully dynamical.

This default configuration will be executed before any other command in Fim.
After this, the "$(HOME)/.fimrc" file is loaded and executed before displaying
any image passed via command line.

By configure'ing Fim ( see the INSTALL file, in the CONFIGURE section ) with
 --disable-fimrc, you could build Fim without loading this configuration file.


</pre><hr><pre>8. Pattern matching				<b class="vimtag">*<a name="pattern-matching">pattern-matching</a>*</b>

Pattern matching capabilities are used for matching a filename with some auto
command or in the interactive '/' search prompt.

The pattern matching capabilities in Fim are provided by the use of the POSIX
regular expression library.

The relevant man page for POSIX regular expressions is 'man 7 regex'.

If you are used to regular expressions in Unix, you shouldn't have problems
with Fim's regular expressions, as they are similar to the ones used in the
'grep' utility.


Otherwise, here are some quick tips for interactive search:

<code class="example">	/my pic.png</code>
will jump to the first picture whom name contains 'my pic.png'

<code class="example">	/^my pic.png$</code>
will jump to 'my pic.png'

<code class="example">	/my.*.png$</code>
will jump to the first .png picture whom name contains 'my'

<code class="example">	/^my.*.png$</code>
will jump to the first .png picture whom name begins with 'my'

When multiple filenames match the search pattern, you can jump to the next
matching with the default <code class="special">&lt;C-n&gt;</code> (control key and n) binding.

If <code class="special">&lt;C-n&gt;</code> doesn't have this effect, hit ':' to get the console, and type in

<code class="example">	:bind 'C-n' "regexp_goto_next";</code>
This should associate that key combination to the action of jumping to the
next searched image.

<code class="note">Note:</code> by setting the variable 'ignorecase' to 0, the searches will be case
sensitive. 'ignorecase' is 1 by default.

</pre><hr><pre>9. Dangers						<b class="vimtag">*<a name="dangers">dangers</a>*</b>

There are plenty of ways of getting the program into an endless loop!
For instance,

<code class="example">	:alias 'loop' 'loop;'</code>
will loop forever by calling itself!

A better example of looping is the following sequence:

<code class="example">	:alias "endless_slideshow" "while(1)<code class="special">{next;display;sleep '1';}</code>;";</code>
<code class="example">	:alias "pornview" "echo 'press to terminate' ;endless_slideshow;";</code>
<code class="example">	:bind "C-p" "pornview";</code>
<code class="example"></code>
This will turn FIM into slideshow mode, which can be interrupted by the
continued pressure of some key (some unbound key is better!).

'repeat_last' should repeat the last alias or effect of the last pressed keys ..
..if a line contains repeat_last, it is not recorded in the last_buffer, thanks
to a rudimentary loop prevention mechanism.

Of course, beware the |<a href="FIM.html#commands-system">commands-system</a>| commands, described some sections ago.

</pre><hr><pre>10.Technicalia	 						<b class="vimtag">*<a name="technicalia">technicalia</a>*</b>

This section should introduce you to the techier core of FIM.

</pre><hr><pre>10.1.Syntax reference 						<b class="vimtag">*<a name="syntax-ref">syntax-ref</a>*</b>

The implemented Fim minilanguage gives the user the possibility of storing
values into variables, then performing simple arithmetics, while loops, and
executing conditionally with the if and if-else construct.

Examples:

<code class="example">	i=0;while(i&lt;10)<code class="special">{next;reload;sleep '1';display;}</code></code>
The effect of such command is a slideshow behaviour with 1 second pauses
between images.

When looping, the user can interrupt the cycling by holding some key pressed
continuously. Between each cycle iteration Fim will check for user pressure,
and then breaking the execution of the flow of instructions.

So, the commands following the loop will be ignored.

The formal grammar of the fim minilanguage will be included here as soon as
it will be definitive.
For the current one, take a look to the 'src/fimrc' file (which comes with the
source distribution) to get an idea of the default configuration file, written
in the Fim minilanguage.

<code class="note">Note</code> that this language is still evolving, and as features come, new chances
of making the language smarter come, so it is right to change the rules for
now.

Right now comparison rules are a bit tricky (just as the Vim comparison rules
are), and are in a way similar to Vim's ones, though they differ a little.

Please have a look at the 'scripts/tests/sanity.fim' file while a definitive
language reference is not available.
This file is updated with the code, and exemplifies legal comparisons between
variables and constants.

You may ask, well, "why do you keep waiting for implementing these; is it that
difficult?".
Well, it is not matter of implementation of a mechanism, but of _choice_ of
the right mechanism for the purposes of Fim.
A lot of questions still await for an answer in Fim. Here are few:
 - should the interpreter cast variables of different types ?
 - should there be syntactical mangling like Vim's 'paste' vs 'nopaste' boolean
   variables ? These can be thought as functors with pointers !
 - should there be enumerations ? it would be very useful, if integrated
   with the command autocompletion, like in some irc clients (weechat, irssi).
 - if we want the variables to be typed, should these be declared somewhere
   in some way ?
 - and functions ? debugging ?

 meanwhile these issues are thought of, Fim code will be mainly cleaned up to
 reach a higher level of generality ( an ambitious aim is to invade X some day,
 optionally of course ), and configure/build/compatibility issues solved.

 Right now, please learn to use the <b class="vimtag">*<a name="many">many</a>*</b> features Fim offers you, by reading
 the examples scattered in this documentation, and in the 'src/fimrc' and the
 'scripts/tests/sanity.fim' files.

<code class="special">&lt;UNFINISHED&gt;</code>

 Basic types:

 double_quoted_string : gets interpreted before evaluation
 single_quoted_string : does not get interpreted
 integer
 float

<code class="special">&lt;UNFINISHED&gt;</code>

 What follows now is an <b class="vimtag">*<a name="incomplete">incomplete</a>*</b> and <b class="vimtag">*<a name="temporary">temporary</a>*</b> sort of grammar for Fim.

 float      ::== <code class="special">{DIGIT}</code>+"."<code class="special">{DIGIT}</code>*
 integer    ::== [0-9]+
 string     ::== """ ( (\\\") | [^\"] )* """
 string     ::== "'" ( (\\\') | [^\'] )* "'"
 ID         ::== [a-z_A-Z][a-z_A-Z0-9]*
 identifier ::== ([gwibv]:)?<code class="special">{ID}</code>
 assignment ::== identifier "=" float
 assignment ::== identifier "=" integer
 assignment ::== identifier "=" expression
 expression ::== integer |<code class="badlink"> string </code>| expression.expression
 expression ::== expression operator expression
 operator   ::== "+" |<code class="badlink"> "-" </code>| "*" |<code class="badlink"> "/" </code>| "%" | boperator
 boperator  ::== "||<code class="badlink">" </code>| "&amp;&amp;" | "!"
 statement  ::== "*" ( integer | float )
 statement  ::== ( "+" |<code class="badlink"> "-" ) ( integer </code>| float ) "%"
 statement  ::== integer "%"
 statement  ::== integer
 argument   ::== expression
 statement  ::== command ( argument )*
 statement  ::== "if" "(" expression ")" command;
 statement  ::== "if" "(" expression ")" "<code class="special">{" statement "}</code>"
 statement  ::== (integer)? statement ";"+ |<code class="badlink"> statement ";" statement </code>| <code class="special">{ statement }</code>
 program    ::== statement

 Some word of explanation for strings : a string is any sequence of character
 enclosed between single or double quotes.
 A string enclosed by single quotes cannot contain a single quote (') if not
 preceded by a backslash (\).
 A string enclosed by double quotes cannot contain a double quote (") if not
 preceded by a backslash (\).
 If a \x<code class="special">&lt;XX&gt;</code> sequence is encountered, <code class="special">&lt;XX&gt;</code> will be interpreted as two
 hexadecimal characters, and the resulting byte will be substituted to the
 \x<code class="special">&lt;XX&gt;</code> sequence.

 With 'command' we referred to Fim commands, as explained in the reference
 documentation section, or aliases.

<code class="special">&lt;UNFINISHED&gt;</code>


</pre><hr><pre>10.2. Framebuffer mini howto				<b class="vimtag">*<a name="framebuffer">framebuffer</a>*</b>

 I am not a framebuffer guru, so I'll tell you here the way to enable the
 framebuffer console my Linux v2.6.17.1. Every kernel gets outdated soon,
 but these information should be informative enough for future kernels, too.
 Outdated, but comprehensive info can be found at :
              http://tldp.org/HOWTO/Framebuffer-HOWTO.html

 Check out also http://doc.trolltech.com/3.3/emb-framebuffer-howto.html

 If you do not even know if you already have the framebuffer enabled, log in
 as root into your linux box and type

  ls -R / &gt; /dev/fb0

 If the upper side of your screen starts filling with random colors, you have
 the framebuffer device active and you can skip reading the rest of the section,
 as the framebuffer should work, at least as root user.

 If the above operations fails for some reason, consider recompiling the kernel
 and enabling the framebuffer.
 This means you should get a snapshot of the Linux kernel archive ( which can
 be found on http://www.kernel.org ) on your computer.

 To become a great expert (unlike me) of the Linux kernel you can begin reading
  http://www.faqs.org/docs/Linux-HOWTO/Kernel-HOWTO.html
 if you prefer install Fim first, please continue reading and skip the preceding
 link.

 As root:

  mkdir -p /usr/src
  cd /usr/src/
  wget http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.1.tar.bz2
  tar xvjf linux-2.6.21.1.tar.bz2
  ln -s linux-2.6.21.1 linux
  cd linux
  make menuconfig

 A blue screen should show, and moving your cursors you should follow/enable :
   Device Drivers  ---&gt;
      Graphics support ---&gt;
       <code class="special">&lt;*&gt;</code> Support for frame buffer devices
       [*]   VESA VGA graphics support
         Console display driver support  ---&gt;
           --- VGA text console
            [*]   Video mode selection support
            <code class="special">&lt;*&gt;</code>   Framebuffer Console support

 Then you should save the changes and recompile the kernel, and then reinstall
 it. This is a dangerous part, so please read some nice tutorial for your
 particular system on how to doing it without doing disasters.

 I assume you learn how to recompile and reinstall your new kernel now..

 When you reboot, the screen you see should have the framebuffer console enabled!

 Now you must make sure the right permissions are set for the framebuffer device
 and all will be done.

 Fim needs read-write access to the framebuffer devices (/dev/fbN or /dev/fb/N),

 If using udev, you can edit :
 /etc/udev/permissions.d/50-udev.permissions
 and set these lines like here :
  # fb devices
  fb:root:root:0600
  fb[0-9]*:root:root:0600
  fb/*:root:root:0600

 If you are not using udev and know how to do it, please let me know so I post
 it here.

 Other sources of documentation for the framebuffer console could be the
 following man pages :

 fbset(1), convert(1), vim(1), fb.modes(8), fbset(8), fbgrab(1), fbdev(4)

 Or the file /usr/src/linux/Documentation/fb/vesafb.txt
</pre><hr><pre>10.3.Hacking							<b class="vimtag">*<a name="hacking">hacking</a>*</b>

 See the guidelines in the Hacking sections in the README file.

</pre><hr><pre>11.Credits 							<b class="vimtag">*<a name="credits">credits</a>*</b>

 Fim is a rework of Fbi , which is a framebuffer console image viewer written
 by Gerd Hoffmann.

 Fim is an idea of Michele Martone, who can be |<a href="FIM.html#contact">contact</a>|'ed through the email
 address scrambled as dezperado _FOobAr_ autistici _Baz_ org.

 In the source archive, there are the doctags.c program and a slightly modified
 vim2html.pl, which were taken from the original source archive of Vim 7.0
 (although not an integral part of Vim but helper programs).

 Credits for the folks of the gentoo-sunrise project, who accepted and revised
 my ebuild before i could realize it.

</pre><hr><pre>12.FAQs 							<b class="vimtag">*<a name="faq">faq</a>*</b>

 Q: We are in $Date: 2009-10-14 23:05:40 +0200 (Wed, 14 Oct 2009) $,
    so why do you still use the framebuffer, uh ?
 A: De gustibus non disputandum est.

 Q: Do you prefer complicated software over simple to use?
 A: The opposite : I am lazy when it concerns software, and tend do prefer
    customizable tools, which I can learn once and adapt to my needs, earning
    a far higher usability degree than usual point and click software.
    Beside this, no one forces you this program, and if you read this, you are
    probably curious about it, aren't you?
    Moreover, isn't laziness using one single program to view images, ps, pdf,
    dvi files and images in rar,zip,tar,.. archives through a sole single
    program ( |<a href="FIM.html#fimgs">fimgs</a>| )?

 Q: When compiling, I get a compilation error when making lex.yy.o or yacc.tab.o!
 A: Please execute 'make report' and mail me its output. It should be due to the
    fact that Fim relies on some experimental features of Bison : |<a href="FIM.html#bugs">bugs</a>|.
    Consider upgrading Bison as a possible solution.

 Q: Is it true that no feature was removed from Fbi ?
 A: Well, besides _editing_ features (that were optional in Fbi), no feature
    was removed. Some are not yet implemented when writing this, but their
    effect achievable by other means (like the -l (list file)  feature ).

 Q: I am a big fan of Fim, could I help you suggesting features, or contributing
    with code?
 A: Yes, please drop me an email ( |<a href="FIM.html#contact">contact</a>| ) or find me on the #fim channel of
    some IRC server which still I have to define.

 Q: I wish to use Fim for commercial purposes, could I?
 A: I think you could, as long as Fim is licensed under the GPL version 2-
    See |<a href="FIM.html#license">license</a>|.

 Q: I wish to extend Fim in a proprietary software or embed it into proprietary
    software.
 A: You couldn't, sorry. Type 'man gpl' to discover why. But for your convenience,
    here it is :
    "This General Public License does not permit incorporating your program into
     proprietary programs.  If your program is a subroutine library, you may consider
     it more useful to permit linking proprietary applications with the library.
     If this is what you want to do, use the GNU Library General Public License
     instead of this License."
    Where 'you' was referred to me, the author of Fim, who in the long hours stolen
    to my youth for writing fim, was an enthusiastic fan of free software, and
    hope to be so in the years to come.

 Q: I wish to use Fim for military purposes, could I ?
 A: Remember me to add somewhere a clause to deny this to you.

 Q: I wish to donate you money, beer, pizza, or a new laptop; could I?
 A: Yes, you could, as in this moment of my life i am completely broken.
    No, I am not a looser, but just not a hawk.
    |<a href="FIM.html#contact">contact</a>| me for the details of sending me the goods.

 Q: I have problems with the framebuffer. Could you help me?
 A: Consider reading the |<a href="FIM.html#framebuffer">framebuffer</a>|sections or google around.

 Q: Which file formats are supported ?
 A: Fim should display the more common file formats (png, jpeg, gif, bmp).
    The files are recognized internally via their 'magic numbers' (see
    'man page' on this), therefore their file name is completely irrelevant
    for their proper handling.
    Consider reading |<a href="FIM.html#fimgs">fimgs</a>| or (man fimgs) to learn how to view archives and
    renderable document files with the help of fim.
    Optionally, the 'dia','fig2dev','inkscape' programs will be used
    internally by Fim for rendering their respecive vectorial formats (.dia,
    .fig,.svg) to a Fim interally supported format.
    Gimp's xcftopnm will be tried to read '.xcf' file format files.
    Moreover, consider that the 'convert' utility (shipped with the
    ImageMagick package) will be tried to convert unrecognized format files,
    as a last try.

</pre><hr><pre>13.BUGS								<b class="vimtag">*<a name="bugs">bugs</a>*</b>

 If you want to know about existing bugs, or report a bug, please consult the
 BUGS file.

 if you want to contribute with help, please read the |<a href="FIM.html#contact">contact</a>| information.

</pre><hr><pre>14.License 							<b class="vimtag">*<a name="license">license</a>*</b>

Fim is free software, and is licensed under the GPLv2, also known as GNU General
Public License, version 2, which is included with the main Fim package, in the
COPYING file.
This is stated too in each source file preamble.

</pre><hr><pre>$Id: FIM.TXT 127 2008-04-08 14:20:31Z dezperado $

 vim:tw=78:fo=tcq2:isk=!-~,^*,^\|,^\":ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on Sun Sep 13 10:46:45 CST 2015</i></p>
</body>
</html>
